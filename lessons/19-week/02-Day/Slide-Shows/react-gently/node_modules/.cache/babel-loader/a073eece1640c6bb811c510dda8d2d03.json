{"ast":null,"code":"Object.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _isFunction2 = require(\"lodash/isFunction\");\n\nvar _isFunction3 = _interopRequireDefault(_isFunction2);\n\nvar _react = require(\"react\");\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _data = require(\"./data\");\n\nvar _data2 = _interopRequireDefault(_data);\n\nvar _collection = require(\"./collection\");\n\nvar _collection2 = _interopRequireDefault(_collection);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nexports.default = {\n  getParentSVG: function getParentSVG(target) {\n    if (target.nodeName === \"svg\") {\n      return target;\n    } else {\n      return this.getParentSVG(target.parentNode);\n    }\n  },\n  getTransformationMatrix: function getTransformationMatrix(svg) {\n    return svg.getScreenCTM().inverse();\n  },\n  getSVGEventCoordinates: function getSVGEventCoordinates(evt) {\n    if (typeof document === \"undefined\") {\n      return {\n        x: evt.nativeEvent.locationX,\n        y: evt.nativeEvent.locationY\n      };\n    }\n\n    var svg = this.getParentSVG(evt.target);\n    var matrix = this.getTransformationMatrix(svg);\n    return {\n      x: this.transformTarget(evt.clientX, matrix, \"x\"),\n      y: this.transformTarget(evt.clientY, matrix, \"y\")\n    };\n  },\n  transformTarget: function transformTarget(target, matrix, dimension) {\n    var a = matrix.a,\n        d = matrix.d,\n        e = matrix.e,\n        f = matrix.f;\n    return dimension === \"y\" ? d * target + f : a * target + e;\n  },\n  getDomainCoordinates: function getDomainCoordinates(scale, domain) {\n    domain = domain || {\n      x: scale.x.domain(),\n      y: scale.y.domain()\n    };\n    return {\n      x: [scale.x(domain.x[0]), scale.x(domain.x[1])],\n      y: [scale.y(domain.y[0]), scale.y(domain.y[1])]\n    };\n  },\n  getDataCoordinates: function getDataCoordinates(scale, x, y) {\n    return {\n      x: scale.x.invert(x),\n      y: scale.y.invert(y)\n    };\n  },\n  getBounds: function getBounds(props) {\n    var x1 = props.x1,\n        x2 = props.x2,\n        y1 = props.y1,\n        y2 = props.y2,\n        scale = props.scale;\n    var point1 = this.getDataCoordinates(scale, x1, y1);\n    var point2 = this.getDataCoordinates(scale, x2, y2);\n\n    var makeBound = function makeBound(a, b) {\n      return [_collection2.default.getMinValue([a, b]), _collection2.default.getMaxValue([a, b])];\n    };\n\n    return {\n      x: makeBound(point1.x, point2.x),\n      y: makeBound(point1.y, point2.y)\n    };\n  },\n  getDatasets: function getDatasets(props) {\n    if (props.data) {\n      return [{\n        data: props.data\n      }];\n    }\n\n    var getData = function getData(childProps) {\n      var data = _data2.default.getData(childProps);\n\n      return Array.isArray(data) && data.length > 0 ? data : undefined;\n    };\n\n    var children = _react2.default.Children.toArray(props.children).reverse();\n\n    var childrenLength = children.length;\n    var dataArr = [];\n    var dataArrLength = 0;\n    var childIndex = 0;\n\n    while (childrenLength > 0) {\n      var child = children[--childrenLength];\n      var childName = child.props.name || childIndex;\n      childIndex++;\n\n      if (child.type && child.type.role === \"axis\") {\n        childIndex++;\n      } else if (child.type && (0, _isFunction3.default)(child.type.getData)) {\n        dataArr[dataArrLength++] = {\n          childName: childName,\n          data: child.type.getData(child.props)\n        };\n      } else if (child.props && child.props.children) {\n        var newChildren = _react2.default.Children.toArray(child.props.children);\n\n        var newChildrenLength = newChildren.length;\n\n        for (var index = 0; index < newChildrenLength; index++) {\n          children[childrenLength++] = newChildren[index];\n        }\n      } else {\n        dataArr[dataArrLength++] = {\n          childName: childName,\n          data: getData(child.props)\n        };\n      }\n    }\n\n    return dataArr;\n  },\n  filterDatasets: function filterDatasets(datasets, bounds) {\n    var _this = this;\n\n    var filtered = datasets.reduce(function (memo, dataset) {\n      var selectedData = _this.getSelectedData(dataset.data, bounds);\n\n      memo = selectedData ? memo.concat({\n        childName: dataset.childName,\n        eventKey: selectedData.eventKey,\n        data: selectedData.data\n      }) : memo;\n      return memo;\n    }, []);\n    return filtered.length ? filtered : null;\n  },\n  getSelectedData: function getSelectedData(dataset, bounds) {\n    var x = bounds.x,\n        y = bounds.y;\n\n    var withinBounds = function withinBounds(d) {\n      return d._x >= x[0] && d._x <= x[1] && d._y >= y[0] && d._y <= y[1];\n    };\n\n    var selectedData = dataset.reduce(function (accum, datum, index) {\n      if (withinBounds(datum)) {\n        accum.data.push(datum);\n        accum.eventKey.push(datum.eventKey === undefined ? index : datum.eventKey);\n      }\n\n      return accum;\n    }, {\n      data: [],\n      eventKey: []\n    });\n    return selectedData.data.length > 0 ? selectedData : null;\n  }\n};","map":null,"metadata":{},"sourceType":"script"}