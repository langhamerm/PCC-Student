{"ast":null,"code":"Object.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _isPlainObject2 = require(\"lodash/isPlainObject\");\n\nvar _isPlainObject3 = _interopRequireDefault(_isPlainObject2);\n\nvar _includes2 = require(\"lodash/includes\");\n\nvar _includes3 = _interopRequireDefault(_includes2);\n\nvar _flatten2 = require(\"lodash/flatten\");\n\nvar _flatten3 = _interopRequireDefault(_flatten2);\n\nvar _data = require(\"./data\");\n\nvar _data2 = _interopRequireDefault(_data);\n\nvar _scale = require(\"./scale\");\n\nvar _scale2 = _interopRequireDefault(_scale);\n\nvar _helpers = require(\"./helpers\");\n\nvar _helpers2 = _interopRequireDefault(_helpers);\n\nvar _collection = require(\"./collection\");\n\nvar _collection2 = _interopRequireDefault(_collection);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n}\n\nexports.default = {\n  getDomain: function getDomain(props, axis) {\n    var propsDomain = this.getDomainFromProps(props, axis);\n\n    if (propsDomain) {\n      return this.padDomain(propsDomain, props, axis);\n    }\n\n    var categoryDomain = this.getDomainFromCategories(props, axis);\n\n    if (categoryDomain) {\n      return this.padDomain(categoryDomain, props, axis);\n    }\n\n    var dataset = _data2.default.getData(props);\n\n    var domain = this.getDomainFromData(props, axis, dataset);\n    return this.cleanDomain(this.padDomain(domain, props, axis), props, axis);\n  },\n  cleanDomain: function cleanDomain(domain, props, axis) {\n    var scaleType = _scale2.default.getScaleType(props, axis);\n\n    if (scaleType !== \"log\") {\n      return domain;\n    }\n\n    var rules = function rules(dom) {\n      var almostZero = dom[0] < 0 || dom[1] < 0 ? -1 / Number.MAX_SAFE_INTEGER : 1 / Number.MAX_SAFE_INTEGER;\n      var domainOne = dom[0] === 0 ? almostZero : dom[0];\n      var domainTwo = dom[1] === 0 ? almostZero : dom[1];\n      return [domainOne, domainTwo];\n    };\n\n    return rules(domain);\n  },\n  getDomainWithZero: function getDomainWithZero(props, axis) {\n    var _this = this;\n\n    var propsDomain = this.getDomainFromProps(props, axis);\n\n    if (propsDomain) {\n      return this.cleanDomain(this.padDomain(propsDomain, props, axis), props, axis);\n    }\n\n    var horizontal = props.horizontal;\n\n    var ensureZero = function ensureZero(domain) {\n      var isDependent = axis === \"y\" && !horizontal || axis === \"x\" && horizontal;\n\n      var min = _collection2.default.getMinValue(domain, 0);\n\n      var max = _collection2.default.getMaxValue(domain, 0);\n\n      var zeroDomain = isDependent ? [min, max] : domain;\n      return _this.padDomain(zeroDomain, props, axis);\n    };\n\n    var categoryDomain = this.getDomainFromCategories(props, axis);\n\n    if (categoryDomain) {\n      return this.cleanDomain(this.padDomain(ensureZero(categoryDomain), props, axis), props, axis);\n    }\n\n    var dataset = _data2.default.getData(props);\n\n    var domain = ensureZero(this.getDomainFromData(props, axis, dataset));\n    return this.cleanDomain(this.padDomain(domain, props, axis), props, axis);\n  },\n  getDomainFromProps: function getDomainFromProps(props, axis) {\n    if (props.domain && props.domain[axis]) {\n      return props.domain[axis];\n    } else if (props.domain && Array.isArray(props.domain)) {\n      return props.domain;\n    }\n\n    return undefined;\n  },\n  getDomainFromData: function getDomainFromData(props, axis, dataset) {\n    var currentAxis = _helpers2.default.getCurrentAxis(axis, props.horizontal);\n\n    var allData = (0, _flatten3.default)(dataset).map(function (datum) {\n      return datum[\"_\" + currentAxis];\n    });\n\n    if (allData.length < 1) {\n      return _scale2.default.getBaseScale(props, axis).domain();\n    }\n\n    var min = _collection2.default.getMinValue(allData);\n\n    var max = _collection2.default.getMaxValue(allData);\n\n    if (min === max) {\n      var adjustedMax = max === 0 ? 1 : max;\n      return [0, adjustedMax];\n    }\n\n    return [min, max];\n  },\n  getDomainFromTickValues: function getDomainFromTickValues(props) {\n    var domain = void 0;\n\n    if (_helpers2.default.stringTicks(props)) {\n      domain = [1, props.tickValues.length];\n    } else {\n      var ticks = props.tickValues.map(function (value) {\n        return +value;\n      });\n      domain = [_collection2.default.getMinValue(ticks), _collection2.default.getMaxValue(ticks)];\n    }\n\n    if (_helpers2.default.isVertical(props)) {\n      domain.reverse();\n    }\n\n    return domain;\n  },\n  getDomainFromCategories: function getDomainFromCategories(props, axis) {\n    var categories = _data2.default.getCategories(props, axis);\n\n    if (!categories) {\n      return undefined;\n    }\n\n    var stringArray = _collection2.default.containsStrings(categories) ? _data2.default.getStringsFromCategories(props, axis) : [];\n    var stringMap = stringArray.length === 0 ? null : stringArray.reduce(function (memo, string, index) {\n      memo[string] = index + 1;\n      return memo;\n    }, {});\n    var categoryValues = stringMap ? categories.map(function (value) {\n      return stringMap[value];\n    }) : categories;\n    return [_collection2.default.getMinValue(categoryValues), _collection2.default.getMaxValue(categoryValues)];\n  },\n  getDomainFromGroupedData: function getDomainFromGroupedData(props, axis, datasets) {\n    var horizontal = props.horizontal;\n    var dependent = axis === \"x\" && !horizontal || axis === \"y\" && horizontal;\n\n    if (dependent && props.categories) {\n      return this.getDomainFromCategories(props, axis);\n    }\n\n    var globalDomain = this.getDomainFromData(props, axis, datasets);\n    var cumulativeData = !dependent ? this.getCumulativeData(props, axis, datasets) : [];\n    var cumulativeMaxArray = cumulativeData.map(function (dataset) {\n      return dataset.reduce(function (memo, val) {\n        return val > 0 ? +val + +memo : memo;\n      }, 0);\n    });\n    var cumulativeMinArray = cumulativeData.map(function (dataset) {\n      return dataset.reduce(function (memo, val) {\n        return val < 0 ? +val + +memo : memo;\n      }, 0);\n    });\n    var cumulativeMin = Math.min.apply(Math, _toConsumableArray(cumulativeMinArray));\n    var domainMin = cumulativeMin < 0 ? cumulativeMin : _collection2.default.getMinValue(globalDomain);\n\n    var domainMax = _collection2.default.getMaxValue.apply(_collection2.default, [globalDomain].concat(_toConsumableArray(cumulativeMaxArray)));\n\n    if (domainMin === domainMax) {\n      var adjustedMax = domainMax === 0 ? 1 : domainMax;\n      return [0, adjustedMax];\n    }\n\n    return [domainMin, domainMax];\n  },\n  getCumulativeData: function getCumulativeData(props, axis, datasets) {\n    var currentAxis = _helpers2.default.getCurrentAxis(axis, props.horizontal);\n\n    var categories = [];\n    var axisValues = [];\n    datasets.forEach(function (dataset) {\n      dataset.forEach(function (data) {\n        if (data.category !== undefined && !(0, _includes3.default)(categories, data.category)) {\n          categories.push(data.category);\n        } else if (!(0, _includes3.default)(axisValues, data[currentAxis])) {\n          axisValues.push(data[currentAxis]);\n        }\n      });\n    });\n\n    var _dataByCategory = function _dataByCategory() {\n      return categories.map(function (value) {\n        return datasets.reduce(function (prev, data) {\n          return data.category === value ? prev.concat(data[axis]) : prev;\n        }, []);\n      });\n    };\n\n    var _dataByIndex = function _dataByIndex() {\n      return axisValues.map(function (value, index) {\n        return datasets.map(function (data) {\n          return data[index] && data[index][\"_\" + currentAxis];\n        });\n      });\n    };\n\n    return categories.length === 0 ? _dataByIndex() : _dataByCategory();\n  },\n  getDomainPadding: function getDomainPadding(props, axis) {\n    var formatPadding = function formatPadding(padding) {\n      return Array.isArray(padding) ? {\n        left: padding[0],\n        right: padding[1]\n      } : {\n        left: padding,\n        right: padding\n      };\n    };\n\n    return (0, _isPlainObject3.default)(props.domainPadding) ? formatPadding(props.domainPadding[axis]) : formatPadding(props.domainPadding);\n  },\n  padDomain: function padDomain(domain, props, axis) {\n    if (!props.domainPadding) {\n      return domain;\n    }\n\n    var padding = this.getDomainPadding(props, axis);\n\n    if (!padding.left && !padding.right) {\n      return domain;\n    }\n\n    var domainMin = _collection2.default.getMinValue(domain);\n\n    var domainMax = _collection2.default.getMaxValue(domain);\n\n    var range = _helpers2.default.getRange(props, axis);\n\n    var rangeExtent = Math.abs(Math.max.apply(Math, _toConsumableArray(range)) - Math.min.apply(Math, _toConsumableArray(range)));\n    var initialPadding = {\n      left: Math.abs(domainMax - domainMin) * padding.left / rangeExtent,\n      right: Math.abs(domainMax - domainMin) * padding.right / rangeExtent\n    };\n    var adjustedDomain = {\n      min: domainMin >= 0 && domainMin - initialPadding.left <= 0 ? 0 : domainMin.valueOf() - initialPadding.left,\n      max: domainMax <= 0 && domainMax + initialPadding.right >= 0 ? 0 : domainMax.valueOf() + initialPadding.right\n    };\n    var finalPadding = {\n      left: Math.abs(adjustedDomain.max - adjustedDomain.min) * padding.left / rangeExtent,\n      right: Math.abs(adjustedDomain.max - adjustedDomain.min) * padding.right / rangeExtent\n    };\n    var finalDomain = {\n      min: domainMin >= 0 && domainMin - finalPadding.left <= 0 ? 0 : domainMin.valueOf() - finalPadding.left,\n      max: domainMax >= 0 && domainMax + finalPadding.right <= 0 ? 0 : domainMax.valueOf() + finalPadding.right\n    };\n    return domainMin instanceof Date || domainMax instanceof Date ? [new Date(finalDomain.min), new Date(finalDomain.max)] : [finalDomain.min, finalDomain.max];\n  },\n  orientDomain: function orientDomain(domain, orientations, axis) {\n    var otherAxis = axis === \"x\" ? \"y\" : \"x\";\n\n    var defaultOrientation = function defaultOrientation(ax) {\n      return ax === \"x\" ? \"bottom\" : \"left\";\n    };\n\n    var flippedAxis = orientations.x === \"left\" || orientations.x === \"right\";\n    var standardOrientation = flippedAxis ? orientations[otherAxis] === defaultOrientation(axis) : orientations[otherAxis] === defaultOrientation(otherAxis);\n\n    if (flippedAxis) {\n      return standardOrientation ? domain.concat().reverse() : domain;\n    } else {\n      return standardOrientation ? domain : domain.concat().reverse();\n    }\n  }\n};","map":null,"metadata":{},"sourceType":"script"}